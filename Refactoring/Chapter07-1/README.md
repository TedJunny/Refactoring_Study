# 7-1 캡슐화(7.1~7.4)
> 모듈을 분리할 때 중요한 포인트는 개발자 외에 노출되어서는 안되는 정보를 잘 숨기는 것. 그런 정보들의 예시로는 내부의 데이터 구조, 클래스 사이의 연결 관계 등이 있다. 
- 이 때 자주 사용되는 리팩터링 방법이 캡슐화이며, 각 세부 챕터에서 설명하는 캡슐화 범위는 아래와 같다.
    - 데이터 구조 : 7.1 레코드 캡슐화하기, 7.2 컬렉션 캡슐화하기
    - 기본형 데이터 : 7.3 기본형을 객체로 바꾸기
    - 임시 변수, 긴 함수 쪼개기 : 7.4 임시 변수를 질의 함수로 바꾸기
    - 내부 정보 : 7.5 클래스 추출하기, 클래스 인라인하기
    - 클래스 사이의 연결 관계 : 7.7 위임 숨기기,, 7.8 중개자 제거하기
    - 함수 : 7.9 알고리즘 교체하기 

## 7.1 레코드 캡슐화하기(Encapsulate Record) 
> 가변 데이터를 레코드가 아닌 클래스로 만들기<br>
- 대부분의 프로그래밍 언어에서는 hash, map, dictionary 등으로 손쉽게 레코드를 만들 수 있도록 함
- 하지만 가변 데이터를 레코드 형태로 저장할 경우 내부에 지정된 필드를 명확히 알 수 없다는 것이 단점. 코드 내에서 이런 데이터를 사용하는 곳이 많을수록 필드의 불분명함으로 발생하는 문제가 커짐
- 캡슐화할 경우 필드 이름을 바꾸기도 수월해짐
- 중첩된 리스트나 레코드를 json/xml 같은 포맷으로 직렬화하는 경우에도 캡슐화를 진행해 포맷 변경이나 추적하기 어려운 데이터의 수정을 보다 쉽게 할 수 있음

**절차**
> 아래 과정에서 변경사항이 있을 때마다 테스트를 진행!

1. 레코드를 담은 변수를 캡슐화
2. 레코드를 감싼 클래스로 해당 변수의 내용 교체. 해당 클래스에 원본 레코드를 반환할 수 있도록 접근자를 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 함
3. 원본 레코드 대신 2에서 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 생성
4. (레코드를 반환하는) 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 변경. 필요한 접근자가 있을 경우 추가하고, 변경할 때마다 테스트 진행
    - 구조가 중첩되는 등 복잡한 레코드라면, 데이터를 갱신하는 클라이언트들에 주의해서 살펴봐야 함. 클라이언트가 단순히 데이터를 읽기만 한다면 데이터의 복제본이나 읽기 전용 프락시 반환 고려 필요
5. 2에서 만든 원본 데이터 반환 접근자와 원본 레코드를 반환하는 함수 제거
6. 레코드의 필드도 중첩된 구조라면 레코드 캡슐화에 더해 컬렉션 캡슐화도 재귀적으로 적용

**원래 코드**
```javascript
organization = {name: "에크미 구스베리", country: "GB"};
```
**리팩토링 후**
```javascript
class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }
    get name() {return this._name;}
    set name(arg) {this._name = arg;}
    get country() {return this._country;}
    set country(arg) {this._country;}
}
```
## 7.2 컬렉션 캡슐화하기(Encapsulate Collection)
> 컬렉션(array, list, set etc)을 소유한 클래스를 통해서만 원소를 변경하도록 한다
- 필드를 참조하는 과정뿐만 아니라 담긴 내용까지 캡슐화를 진행하는 것
- 컬렉션 변수로의 접근을 캡슐화할 때 게터가 컬렉션 원본을 반환하도록 할 경우, 눈치채지 못하는 사이에 컬렉션의 원소가 바뀌는 상황이 발생할 수 있음
- 이런 상황을 막기 위해 컬렉션 게터가 원본을 반환하지 않도록 만드는 과정이 필요함. 아래처럼 여러가지 방법이 존재.
    - 컬렉션 게터를 제공하지만 컬렉션 원본이 아닌 복제본을 반환
    - 컬렉션을 읽기 전용으로 제공
    - 클래스의 메서드를 거치지 않을 경우 컬렉션을 반환하지 않도록 함(부가적인 코드 증가 및 컬렉션 연산 조합이 까다로워져 권장하지 않음)
- 코드의 일관성을 지키기 위해서는 위의 방법들 중 하나를 선택하여 컬렉션 접근 함수의 동작 방식을 통일해야 함.

**절차**
> 아래 과정에서 변경사항이 있을 때마다 테스트를 진행!
1. 아직 컬렉션이 캡슐화되지 않았다면 캡슐화 진행
2. 컬렉션에 원소를 추가/제거하는 함수 추가
    - 컬렉션 원본을 통째로 바꾸는 세터는 제거. 세터 제거가 불가능한 상황이라면 컬렉션을 복제해 저장하도록 함
3. 정적 검사 수행
4. 코드 내에서 컬렉션을 참조하는 부분을 모두 검색. 컬렉션의 변경자를 호출하는 코드가 모두 2의 추가/제거 함수를 호출하도록 수정. 
5. 컬렉션 게터를 수정. 원본 컬렉션 대신 복제본이나 읽기 전용 프락시를 반환하도록 해 수정 가능성 차단

**원래 코드**
```javascript
class Person {
    get courses() {return this._courses;}
    set courses(aList) {this._courses = aList;}
}
```
**리팩토링 후**
```javascript
class Person {
    get courses() {return this._courses.slice();} // 복제본 제공!
    addCourse(aCourse) {...}
    removeCourse(aCourse) {...}
}
```

## 7.3 기본형을 객체로 바꾸기(Replace Primitive with Object)
> 단순한 출력 이상으로 활용되는 데이터들은 모두 전용 클래스를 정의한다
- 데이터가 간단히 출력되는 것에서 벗어나 로직(포매팅, 일부 데이터 추출 등)에 활용되기 시작하면 중복 코드가 증가
- 처음에는 기본형 데이터를 그냥 감싼 것과 다름없이 보이지만, 프로그램이 커질수록 필요한 동작들을 클래스에 그대로 추가하면 되기 때문에 점점 효율이 높아짐

**절차**
> 아래 과정에서 변경사항이 있을 때마다 테스트를 진행!
1. 아직 변수를 캡슐화하지 않았다면 캡슐화 진행
2. 단순한 값 클래스 생성. 생성자는 기존 값을 인수로 받아 저장하고, 이 값을 반환하는 게터 추가
3. 정적 검사 수행
4. 2에서 만든 클래스의 인스턴스를 새로 만들어서 필드에 저장하도록 세터(1에서 변수를 캡슐화하며 만든 세터) 수정. 이미 있다면 필드 타입 적절히 변경
5. 2에서 만든 클래스의 게터를 호출한 결과를 반환하도록 게터(1에서 변수 캡슐화하며 만든 게터) 수정
6. 함수 이름을 바꿀 경우 원본 접근자의 동작을 더 잘 드러낼 수 있을지 검토

**원래 코드**
```javascript
orders.filter(o => "high" === o.priority
                || "rush" === o.priority);
```
**리팩토링 후**
```javascript
orders.filter(o => o.priority.higherThan(new Priority("normal")))
```
## 7.4 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query)
> 임시 변수를 함수화하여 재사용성을 높이고 중복 코드를 방지한다
- 함수 안에서 어떤 코드의 결과를 뒤에서 다시 참조할 목적으로 임시 변수를 사용하는 경우가 있음 
- 하지만 다른 함수에 임시 변수를 계속 전달해야 하기 때문에 번거로움이 발생. 이 불편함을 함수화를 통해 해결 가능 
- 이렇게 할 경우 새로 추출한 함수와 원래 함수의 경계가 더 분명해지고, 의존 관계나 부수 효과를 찾는 데 도움이 됨
- 비슷한 계산을 수행하는 타 함수에서도 사용 가능
- 다만 로직을 수행할 때마다 값이 바뀌는 경우는 해당 방법을 사용해선 안 됨

**절차**
> 아래 과정에서 변경사항이 있을 때마다 테스트를 진행!
1. 변수가 사용되기 전에 값이 확실하게 결정되는지, 변수를 사용할 때마다 결과가 매번 달라지지는 않는지 확인한다.
2. 읽기 전용으로 만들 수 있는 변수는 읽기 전용으로 만든다.
3. 변수 대입문(분기 처리 등)을 함수로 추출
4. 변수 인라인하기로 임시 변수를 제거 

**원래 코드**
```javascript
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
    return basePrice * 0.95;
else
    return basePrice * 0.98;
```
**리팩토링 후**
```javascript
get basePrice() {this._quantity * this._itemPrice;}
...
if (this.basePrice > 1000)
    return this.basePrice * 0.95;
else
    return this.basePrice * 0.98;
```